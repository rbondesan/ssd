{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Personal implementation of arXiv:1702.03037 [cs.MA] in preparation for Deepmind application.\n",
    "\n",
    "Refs:\n",
    "\n",
    "[1] DQN paper \n",
    "\n",
    "[2] An implementation of a simpler game in PyTorch at http://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html\n",
    "\n",
    "Language chosen PyTorch since new, python, GPU."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# General import\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from collections import namedtuple\n",
    "from itertools import count\n",
    "from copy import deepcopy\n",
    "from PIL import Image\n",
    "\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import torch.autograd as autograd\n",
    "import torch.nn.functional as F\n",
    "import torchvision.transforms as T\n",
    "\n",
    "# is_ipython = 'inline' in matplotlib.get_backend()\n",
    "# if is_ipython:\n",
    "#     from IPython import display"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Markov game class\n",
    "\n",
    "Define first a Markov game class for 2 players. Define right away the gathering game class, no need of a parent class. This replaces the environment class (e.g. OpenAI gym).\n",
    "\n",
    "Members are:\n",
    "\n",
    "- States\n",
    "    - A state is the screen image s \\in S.\n",
    "    - It also has actions of each player: A_1, A_2\n",
    "    - Discount factor gamma\n",
    "\n",
    "- Public methods\n",
    "    - observation function O(s,i) which returns a the portion of screen visible by a player (same size for any i)\n",
    "    - transition function: T : A_1 x A_2 -> \\Delta(S). We will consder a deterministic process, which returns next state.\n",
    "    - Reward function r_i : S x A_1 x A_2 -> R\n",
    "    \n",
    "    Note: I think that in gym reward and transition are put together in env.step(action) which returns reward and updates the state.\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [],
   "source": [
    "class gathering_game():\n",
    "    \"\"\"\n",
    "    Gathering game class. An object has the following attributes:\n",
    "    \n",
    "    - s : ndarray representing the image, the current state of the screen\n",
    "    - dir1, dir2 : direction of view of player 1,2. one of 0,1,2,3 = up,down,left,right\n",
    "    - pars:\n",
    "        - discount factor gamma\n",
    "        - N_apples = number of frames after which apple respawns\n",
    "        - N_tagged = number of frames a player hit by beam is removed from game\n",
    "        - W = width screen, odd\n",
    "        - H = height screen, odd\n",
    "        - size_obs_front = number of sites the players can see in front of them\n",
    "        - size_obs_side = number of sites the players can see on their side\n",
    "    \n",
    "    - action : a dictionary returning a onehot vector for each action among\n",
    "      step forward, step back-ward, step left, step right, rotate left, rotate right, use beam and stand still.\n",
    "    - gamma : discount factor\n",
    "    \n",
    "    It also has methods to update the state (transition function) and to return the reward.\n",
    "    \n",
    "    Random thoughts:\n",
    "    -agents are not transparent, so if i cannot move to position of j, i,j in {1,2}. Similarly rigid boundary.\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    def get_init_screen(self,W,H):\n",
    "        \"\"\"Initialize the screen. \n",
    "        \n",
    "        Apples are green and each player sees himself blue and the opponent red. \n",
    "        We choose to save player 1 blue and player 2 red, and to exchange\n",
    "        blue with red in the observation function of player 2.\n",
    "        \n",
    "        Returns the initial frame.\n",
    "        \n",
    "        \"\"\"\n",
    "        \n",
    "        s = np.zeros((3,W,H),dtype=np.uint8) # black background\n",
    "        \n",
    "        mid_x = int((W-1)/2)+1\n",
    "        mid_y = int((H-1)/2)+1\n",
    "        mid = np.array([mid_x,mid_y]) # coordinate central point\n",
    "        dx = np.array([1,0])\n",
    "        dy = np.array([0,1])\n",
    "        # from top to bottom\n",
    "        pos_apples = np.array([mid+2*dy,\n",
    "                      mid+dy-dx,mid+dy,mid+dy+dx,\n",
    "                      mid-2*dx,mid-dx,mid,mid+dx,mid+2*dx,\n",
    "                      mid-dy-dx,mid-dy,mid-dy+dx,\n",
    "                      mid-2*dy])\n",
    "        s[1,pos_apples[:,0],pos_apples[:,1]] = 255 # green\n",
    "        # Starting positions of players, symmetric at left border, so x = 0\n",
    "        init_x = 0\n",
    "        s[2,init_x,mid_y+1] = 255 # blue\n",
    "        s[0,init_x,mid_y-1] = 255 # red\n",
    "        \n",
    "        return s\n",
    "    \n",
    "    def __init__(self, pars):\n",
    "        self.s = self.get_init_screen(pars['W'],pars['H'])\n",
    "        self.pars = pars\n",
    "        # initial directions, set also a dictionary used later which sets the absolute notions of \n",
    "        # up, down, left and right for an absolute observer.\n",
    "        self.dir_dict = {'up':0,'down':1,'left':2,'right':3}\n",
    "        self.dir1 = self.dir_dict['right']\n",
    "        self.dir2 = self.dir_dict['right']\n",
    "    \n",
    "#     def get_obs_window(self, d, pos_x, pos_y):\n",
    "#         \"\"\"\n",
    "#         d = direction of player, pos_x and pos_y its position.\n",
    "        \n",
    "#         It should be size_obs_front ahead and size_obs_side to left/right, \n",
    "#         taking into account boundaries.\n",
    "        \n",
    "#         Returns obs_slc_x, obs_slc_y slices giving the extension of the window in x and y direction.\n",
    "#         \"\"\"\n",
    "\n",
    "#         # determine case by case the distance to boundary ahead and player's left/right side\n",
    "#         # given a direction, the observation\n",
    "#         if self.dir1 == self.dir_dict['up']:\n",
    "#             obs_window_top = min(self.pars['H'] - 1 - pos_y, self.pars['size_obs_ahead']) + 1 #+1 is position of player\n",
    "#             obs_window_bottom = pos_y\n",
    "#             obs_window_right = min(self.pars['W'] - 1 - pos_x, self.pars['size_obs_side']) + 1 #+1 is position of player\n",
    "#             obs_window_left = min(pos_x, self.pars['size_obs_side'])\n",
    "\n",
    "#         elif self.dir1 == self.dir_dict['down']:\n",
    "#             obs_window_top = pos_y + 1 #+1 is position of player\n",
    "#             obs_window_bottom = min(pos_y, self.pars['size_obs_ahead'])\n",
    "#             obs_window_right = min(self.pars['W'] - 1 - pos_x, self.pars['size_obs_side']) + 1 #+1 is position of player\n",
    "#             obs_window_left = min(pos_x, self.pars['size_obs_side'])\n",
    "\n",
    "#         elif self.dir1 == self.dir_dict['left']:\n",
    "#             obs_window_top = min(self.pars['H'] - 1 - pos_y, self.pars['size_obs_side']) + 1 #+1 is position of player\n",
    "#             obs_window_bottom = min(pos_y, self.pars['size_obs_side'])\n",
    "#             obs_window_right = self.pars['W'] - 1 - pos_x + 1 #+1 is position of player\n",
    "#             obs_window_left = min(pos_x, self.pars['size_obs_ahead'])\n",
    "            \n",
    "#         elif self.dir1 == self.dir_dict['right']:\n",
    "#             obs_window_top = min(self.pars['H'] - 1 - pos_y, self.pars['size_obs_side']) + 1 #+1 is position of player\n",
    "#             obs_window_bottom = min(pos_y, self.pars['size_obs_side'])\n",
    "#             obs_window_right = min(self.pars['W'] - 1 - pos_x, self.pars['size_obs_ahead']) + 1#+1 is position of player\n",
    "#             obs_window_left = pos_x\n",
    "        \n",
    "#         slc_obs_x = slice(obs_window_left,obs_window_right)\n",
    "#         slc_obs_y = slice(obs_window_bottom,obs_window_top)\n",
    "        \n",
    "#         return slc_obs_x, slc_obs_y\n",
    "    \n",
    "    def get_obs(self, d, pos_x, pos_y):\n",
    "        \"\"\"\n",
    "        d = direction of player, pos_x and pos_y its position.\n",
    "        \n",
    "        It should be size_obs_front ahead and size_obs_side to left/right, \n",
    "        taking into account boundaries.\n",
    "        \n",
    "        Returns:\n",
    "        - obs_screen_x, obs_screen_y slices giving the slice of the screen observed in x and y direction.\n",
    "        - pad: array with 4 components telling how many zeros need to be padded to fill the observed region outside\n",
    "               the screen.\n",
    "        \"\"\"\n",
    "\n",
    "        # determine case by case the distance to boundary ahead and player's left/right side\n",
    "        # given a direction, the observation\n",
    "        if self.dir1 == self.dir_dict['up']:\n",
    "            obs_window_top = pos_y + self.pars['size_obs_ahead']\n",
    "            obs_window_bottom = pos_y\n",
    "            obs_window_right = pos_x + self.pars['size_obs_side']\n",
    "            obs_window_left = pos_x - self.pars['size_obs_side']\n",
    "\n",
    "        elif self.dir1 == self.dir_dict['down']:\n",
    "            obs_window_top = pos_y \n",
    "            obs_window_bottom = pos_y - self.pars['size_obs_ahead']\n",
    "            obs_window_right = pos_x + self.pars['size_obs_side']\n",
    "            obs_window_left = pos_x - self.pars['size_obs_side']\n",
    "\n",
    "        elif self.dir1 == self.dir_dict['left']:\n",
    "            obs_window_top = pos_y + self.pars['size_obs_side']\n",
    "            obs_window_bottom = pos_y - self.pars['size_obs_side']\n",
    "            obs_window_right = pos_x\n",
    "            obs_window_left = pos_x - self.pars['size_obs_ahead']\n",
    "            \n",
    "        elif self.dir1 == self.dir_dict['right']:\n",
    "            obs_window_top = pos_y + self.pars['size_obs_side']\n",
    "            obs_window_bottom = pos_y - self.pars['size_obs_side']\n",
    "            obs_window_right = pos_x + self.pars['size_obs_ahead']\n",
    "            obs_window_left = pos_x\n",
    "        \n",
    "        # determine how many extra black pixels have to be added at top,bottom,left,right \n",
    "        # in case the observation window exceeds the dimension of the screen.\n",
    "        # Then screen acts then as a \"fence\" and inside and outside it all the pixels are seen\n",
    "        # black by the players.\n",
    "        pad = [0,0,0,0]\n",
    "        dtop = obs_window_top - self.pars['H']\n",
    "        if dtop > 0:\n",
    "            pad[dir_dict['top']] = dtop\n",
    "            obs_window_top = self.pars['H']\n",
    "        dbottom = 0 - obs_window_bottom\n",
    "        if dbottom > 0:\n",
    "            pad[dir_dict['bottom']] = dbottom\n",
    "            obs_window_top = 0\n",
    "        dright = obs_window_right - self.pars['W']\n",
    "        if dright > 0:\n",
    "            pad[dir_dict['right']] = dright\n",
    "            obs_window_top = self.pars['W']\n",
    "        dleft = 0 - obs_window_left\n",
    "        if dleft > 0:\n",
    "            pad[dir_dict['left']] = dleft\n",
    "            obs_window_left = 0\n",
    "            \n",
    "        slc_screen_x = slice(obs_window_left,obs_window_right+1)\n",
    "        slc_screen_y = slice(obs_window_bottom,obs_window_top+1)\n",
    "        \n",
    "        return slc_obs_x, slc_obs_y, pad\n",
    "    \n",
    "    def obs_1(self):\n",
    "        \"\"\"Observation function of player 1.\n",
    "        \n",
    "        \"\"\"\n",
    "        # determine position of player 1: where blue\n",
    "        blue_s = self.s[2,:,:]\n",
    "        pos_1 = blue_s[blue_s == 255]\n",
    "        slc_obs_x, slc_obs_y, pad = self.get_obs(self.dir1, pos_1[0], pos_1[1])        \n",
    "        ret = self.s[:,slc_obs_x,slc_obs_y]\n",
    "        ret = np.lib.pad(ret, ((pad[self.dir_dict['top']], pad[self.dir_dict['bottom']]), \n",
    "                               (pad[self.dir_dict['left']], pad[self.dir_dict['right']])), \n",
    "                         'constant', constant_values=(0))\n",
    "        return ret\n",
    "    \n",
    "    def obs_2(self):\n",
    "        \"\"\"Observation function of player 1. \n",
    "        Invert blue with red and still take blue as player's color.\n",
    "        \n",
    "        \"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 156,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 33, 11)\n",
      "(11, 33, 3)\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAX0AAACSCAYAAACpHBqyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz\nAAALEgAACxIB0t1+/AAACu1JREFUeJzt3X+oZOddx/H3x22iso0msTENyaapulRakbRetgaDRGti\nEgpRCGUDapTCbYuFBBUs/aOpEaGK1h8gCasJpmKblqZpF6mmSw00gsbsXTfNjzVmWzYk65qQbJt0\nsVjWfP1jzsLtzdwfO2fuzpz7vF8wzJlnnjvneTiznzn7zJnnSVUhSWrD98y6AZKkM8fQl6SGGPqS\n1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDXkdbNuwEpJ/ImwJJ2+F6vqgvUqeaYvSVvDMxup\n1Cv0k1yb5Kkkh5N8aMzz35vk093zDye5rM/+JEn9TBz6SbYBfwlcB7wVuCnJW1dUey/wjar6MeBP\ngT+cdH+SpP76nOnvAg5X1der6jvAvcANK+rcANzTbX8WeFeS9NinJKmHPqF/MfDsssfPdWVj61TV\nSeBl4IdWvlCSxST7k+zv0R5J0jrm4uqdqtoD7AGv3pGkzdTnTP8osGPZ40u6srF1krwO+EHgpR77\nlCT10Cf0HwF2JnlzkrOB3cDeFXX2Ajd32zcC/1Qu1SVJMzPx8E5VnUzyQeABYBtwd1U9keR2YH9V\n7QXuAv42yWHgOKMPBknSjGTeTrwd05ekiSxV1cJ6lfxFriQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9\nSWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIROHfpIdSR5M\n8mSSJ5LcMqbOVUleTnKwu32kX3MlSX1MvFwicBL47ao6kOQcYCnJvqp6ckW9h6rq3T32I0makonP\n9KvqWFUd6La/BRwCLp5WwyRJ0zeVMf0klwFvBx4e8/QVSR5N8g9J3jaN/UmSJtNneAeAJK8H7gNu\nrapXVjx9AHhTVZ1Icj3weWDnmNdYBBb7tkWStLZU1eR/nJwF/D3wQFV9fAP1jwALVfXiGnUmb5Ak\ntWupqhbWq9Tn6p0AdwGHVgv8JG/s6pFkV7e/lybdpySpnz7DOz8D/CrwWJKDXdmHgUsBqupO4Ebg\nA0lOAt8Gdlef/1pIknrpNbyzGRzekaSJbO7wjiRpeAx9SWqIoS9JDTH0Jakhhr4kNaT3L3Kl5m30\nerNsaiukDfFMX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDXE0Jekhhj6ktQQQ1+SGjJ3of9TjH7g\nuN5N2lQbeROe7ptx2q8nTaBX6Cc5kuSxJAeT7B/zfJL8RZLDSb6a5B199idJ6mcac+/83BoLnV8H\n7Oxu7wTu6O4lSTOw2cM7NwCfqJF/Bc5NctEm71OStIq+oV/Al5IsJVkc8/zFwLPLHj/XlUmSZqDv\n8M6VVXU0yQ8D+5L8R1V95XRfpPvAWAS4tGeDJEmr63WmX1VHu/sXgPuBXSuqHAV2LHt8SVe28nX2\nVNVCVS1c0KdBkqQ1TRz6SbYnOefUNnAN8PiKanuBX+uu4vlp4OWqOjZxayVJvfQZ3rkQuD/Jqdf5\nZFX9Y5L3A1TVncAXgeuBw8D/AL/Rr7mSpD5SNV+/BllI6jUX/I/hynPaVLP8Z+GbW5NZqqqF9SrN\n3Rq5S/ie1yaar3Oc8VxzV5to7qZhkCRtHkNfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SG\nGPqS1JA5DH1XydUmygZvszSENmqw5jD0JUmbxdCXpIYY+pLUEENfkhpi6EtSQwx9SWpInzVy35Lk\n4LLbK0luXVHnqiQvL6vzkf5NliRNauKVs6rqKeBygCTbgKPA/WOqPlRV7550P5Kk6ZnW8M67gK9V\n1TNTej1J0iaY1hq5u4FPrfLcFUkeBf4L+J2qemJlhSSLwOKykik1S5rQ6bwFXdNWA5KqflMaJDmb\nUaC/raqeX/HcDwCvVtWJJNcDf15VO9d5PedY0LAY+poPS1W1sF6laQzvXAccWBn4AFX1SlWd6La/\nCJyV5A1T2KckaQLTCP2bWGVoJ8kbk6Tb3tXt76Up7FOSNIFeY/pJtgNXA+9bVvZ+gKq6E7gR+ECS\nk8C3gd3VdzxJkjSx3mP60+aYvgbHMX3NhzM2pi9JGghDX5IaYuhLUkMMfUlqiKEvSQ2Z1jQMUru8\nKkcD4pm+JDXE0Jekhhj6ktQQQ1+SGmLoS1JDDH1JaoihL0kNMfQlqSGGviQ1xNCXpIasG/pJ7k7y\nQpLHl5Wdn2Rfkqe7+/NW+dubuzpPJ7l5mg2XJJ2+jZzp/w1w7YqyDwFfrqqdwJe7x98lyfnAbcA7\ngV3Abat9OEiSzox1Q7+qvgIcX1F8A3BPt30P8Etj/vQXgX1VdbyqvgHs47UfHpKkM2jSMf0Lq+pY\nt/3fwIVj6lwMPLvs8XNdmSRpRnpPrVxV1Xcx8ySLwGLftkiS1jbpmf7zSS4C6O5fGFPnKLBj2eNL\nurLXqKo9VbWwkZXcJUmTmzT09wKnrsa5GfjCmDoPANckOa/7AvearkySNCMbuWTzU8C/AG9J8lyS\n9wIfA65O8jTwC91jkiwk+WuAqjoO/D7wSHe7vSuTJM1IqnoNx09d3+8HJKlRSxsZIp/HNXJfBJ5Z\nUfaGrnwrsC/zaav0Zav0A+zL6XrTRirN3Zn+OEn2b5Uvee3LfNoqfdkq/QD7slmce0eSGmLoS1JD\nhhL6e2bdgCmyL/Npq/Rlq/QD7MumGMSYviRpOoZypi9JmoK5D/0k1yZ5KsnhJK+ZwnlIkhxJ8liS\ng0n2z7o9p6PPugrzZJV+fDTJ0e64HExy/SzbuFFJdiR5MMmTSZ5IcktXPqjjskY/Bndcknxfkn9L\n8mjXl9/ryt+c5OEuxz6d5OyZtXGeh3eSbAP+E7ia0SydjwA3VdWTM23YhJIcARaqanDXHif5WeAE\n8Imq+omu7I+A41X1se4D+byq+t1ZtnM9q/Tjo8CJqvrjWbbtdHXzXl1UVQeSnAMsMZrm/NcZ0HFZ\nox/vYWDHJUmA7VV1IslZwD8DtwC/BXyuqu5NcifwaFXdMYs2zvuZ/i7gcFV9vaq+A9zLaC5/nWE9\n1lWYK6v0Y5Cq6lhVHei2vwUcYjR9+aCOyxr9GJwaOdE9PKu7FfDzwGe78pkek3kP/a02J38BX0qy\n1E0nPXQbWVdhKD6Y5Kvd8M9cD4eMk+Qy4O3Awwz4uKzoBwzwuCTZluQgo9mH9wFfA75ZVSe7KjPN\nsXkP/a3myqp6B3Ad8JvdUMOWUKNxwvkdK1zbHcCPApcDx4A/mW1zTk+S1wP3AbdW1SvLnxvScRnT\nj0Eel6r6v6q6nNF08ruAH59xk77LvIf+hufkH4KqOtrdvwDcz+gNMWQbWVdh7lXV890/1FeBv2JA\nx6UbN74P+Luq+lxXPLjjMq4fQz4uAFX1TeBB4Arg3CSn5jqbaY7Ne+g/Auzsvvk+G9jNaC7/wUmy\nvfuSiiTbGa0v8PjafzX3NrKuwtw7FZCdX2Ygx6X70vAu4FBVfXzZU4M6Lqv1Y4jHJckFSc7ttr+f\n0UUohxiF/41dtZkek7m+egegu0zrz4BtwN1V9QczbtJEkvwIo7N7GM1u+skh9aVbV+EqRrMFPg/c\nBnwe+AxwKaOZUd8z72smrNKPqxgNIRRwBHjfsjHxuZXkSuAh4DHg1a74w4zGwwdzXNbox00M7Lgk\n+UlGX9RuY3RS/Zmqur37938vcD7w78CvVNX/zqSN8x76kqTpmffhHUnSFBn6ktQQQ1+SGmLoS1JD\nDH1JaoihL0kNMfQlqSGGviQ15P8BU9+a27swzWAAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f53cc339b00>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# test gathering_game class\n",
    "game_pars={}\n",
    "game_pars['gamma']=.99\n",
    "game_pars['N_apples']=10\n",
    "game_pars['N_tagged']=10\n",
    "# local vars, should not be changed\n",
    "game_pars['W'] = 33 # Width, always odd\n",
    "game_pars['H'] = 11 # Height, always odd\n",
    "game_pars['size_obs_front'] = 15 # number of sites the players can see in front of them\n",
    "game_pars['size_obs_side'] = 10 # number of sites the players can see on their side\n",
    "    \n",
    "test = gathering_game(game_pars)\n",
    "\n",
    "print(test.s.shape)\n",
    "to_show = test.s.transpose((2,1,0))\n",
    "print(to_show.shape)\n",
    "plt.imshow(to_show)\n",
    "plt.show()\n",
    "\n",
    "# TODO: test of obs_1  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### DQN class\n",
    "\n",
    "Just take it from [2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Helper function that compute the output of a cross correlation\n",
    "def dim_out(dim_in,ks,stride):\n",
    "    return math.floor((dim_in-ks)/stride+1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DQN(nn.Module):\n",
    "        \n",
    "    def __init__(self, hp):\n",
    "        \"\"\"hp = hyperparameters, dictionary\"\"\"\n",
    "        super(DQN, self).__init__()\n",
    "        # Conv2D has arguments C_in, C_out, ... where C_in is the number of input channels and C_out that of\n",
    "        # output channels, not to be confused with the size of the image at input and output which is automatically\n",
    "        # computed given the input and the kernel_size. \n",
    "        # Further, in the help, (N,C,H,W) are resp. number of samples, number of channels, height, width.\n",
    "        # Note: that instead nn.Linear requires both number of input and output neurons. The reason is that\n",
    "        # conv2d only has parameters in the kernel, which is independent of the number of neurons.\n",
    "        # Note: we do not use any normalization layer\n",
    "        self.C_H = hp['C_H']\n",
    "        ks = hp['kernel_size']\n",
    "        stride = hp['stride']\n",
    "        self.conv1 = nn.Conv2d(hp['C_in'], self.C_H, kernel_size=ks, stride=stride)\n",
    "        self.H1 = dim_out(hp['H'],ks,stride)\n",
    "        self.W1 = dim_out(hp['W'],ks,stride)\n",
    "        in_size = self.C_H*self.W1*self.H1\n",
    "        self.lin1 = nn.Linear(in_size, in_size) #lots of parameters!\n",
    "        self.conv2 = nn.Conv2d(self.C_H, self.C_H, kernel_size=ks, stride=stride)\n",
    "        H2 = dim_out(self.H1,ks,stride)\n",
    "        W2 = dim_out(self.W1,ks,stride)\n",
    "        in_size = self.C_H*W2*H2\n",
    "        self.lin2 = nn.Linear(in_size, hp['C_out'])\n",
    "\n",
    "    def forward(self, x):\n",
    "        # Apply rectified unit (relu) after each layer\n",
    "        x = F.relu(self.conv1(x))\n",
    "        # to feed into self.lin. we reshape x has a (size(0), rest) tensor where size(0) is number samples.\n",
    "        # -1 tells it to infer size automatically.\n",
    "        x = x.view(x.size(0), -1) \n",
    "        x = F.relu(self.lin1(x))\n",
    "        # reshape to feed it into conv2, this time:\n",
    "        x = x.view(x.size(0), self.C_H, self.H1, self.W1) \n",
    "        x = F.relu(self.conv2(x))\n",
    "        # reshape to feed it into lin2, this time:\n",
    "        x = x.view(x.size(0), -1)\n",
    "        x = F.relu(self.lin2(x))    \n",
    "        return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([32, 3, 5, 5])\n",
      "torch.Size([32])\n",
      "torch.Size([2496, 2496])\n",
      "torch.Size([2496])\n",
      "torch.Size([32, 32, 5, 5])\n",
      "torch.Size([32])\n",
      "torch.Size([8, 160])\n",
      "torch.Size([8])\n",
      "y :  torch.Size([10, 8])\n",
      "Variable containing:\n",
      "1.00000e-02 *\n",
      "  0.7682\n",
      "  0.0000\n",
      "  1.3098\n",
      "  0.6328\n",
      "  3.6772\n",
      "  6.0608\n",
      "  1.7848\n",
      "  0.0000\n",
      "[torch.FloatTensor of size 8]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# TEST of DQN\n",
    "\n",
    "hp = {}\n",
    "hp['C_in'] = 3 # for RGB\n",
    "hp['C_H'] = 32 # number of hidden units (or channels)\n",
    "hp['C_out'] = 8 # number of actions.\n",
    "hp['kernel_size'] = 5 \n",
    "hp['stride'] = 2\n",
    "hp['H'] = 30\n",
    "hp['W'] = 15\n",
    "\n",
    "#print(dim_out(dim_out(30,5,2),5,2))\n",
    "\n",
    "model_test = DQN(hp)\n",
    "for p in model_test.parameters():\n",
    "    print(p.size())\n",
    "\n",
    "N = 10\n",
    "x_test = autograd.Variable(torch.randn(N, 3, hp['H'], hp['W']))\n",
    "y_pred = model_test(x_test)\n",
    "print(\"y : \",y_pred.data.size())\n",
    "print(y_pred[0,:])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2+"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
